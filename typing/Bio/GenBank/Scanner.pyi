"""
This type stub file was generated by pyright.
"""

"""Internal code for parsing GenBank and EMBL files (PRIVATE).

This code is NOT intended for direct use.  It provides a basic scanner
(for use with a event consumer such as Bio.GenBank._FeatureConsumer)
to parse a GenBank or EMBL file (with their shared INSDC feature table).

It is used by Bio.GenBank to parse GenBank files
It is also used by Bio.SeqIO to parse GenBank and EMBL files

Feature Table Documentation:

- http://www.insdc.org/files/feature_table.html
- http://www.ncbi.nlm.nih.gov/projects/collab/FT/index.html
- ftp://ftp.ncbi.nih.gov/genbank/docs/
"""
class InsdcScanner:
    """Basic functions for breaking up a GenBank/EMBL file into sub sections.

    The International Nucleotide Sequence Database Collaboration (INSDC)
    between the DDBJ, EMBL, and GenBank.  These organisations all use the
    same "Feature Table" layout in their plain text flat file formats.

    However, the header and sequence sections of an EMBL file are very
    different in layout to those produced by GenBank/DDBJ.
    """
    RECORD_START = ...
    HEADER_WIDTH = ...
    FEATURE_START_MARKERS = ...
    FEATURE_END_MARKERS = ...
    FEATURE_QUALIFIER_INDENT = ...
    FEATURE_QUALIFIER_SPACER = ...
    SEQUENCE_HEADERS = ...
    def __init__(self, debug=...) -> None:
        """Initialize the class."""
        ...
    
    def set_handle(self, handle): # -> None:
        """Set the handle attribute."""
        ...
    
    def find_start(self): # -> str | None:
        """Read in lines until find the ID/LOCUS line, which is returned.

        Any preamble (such as the header used by the NCBI on ``*.seq.gz`` archives)
        will we ignored.
        """
        ...
    
    def parse_header(self): # -> list[Unknown]:
        """Return list of strings making up the header.

        New line characters are removed.

        Assumes you have just read in the ID/LOCUS line.
        """
        ...
    
    def parse_features(self, skip=...):
        """Return list of tuples for the features (if present).

        Each feature is returned as a tuple (key, location, qualifiers)
        where key and location are strings (e.g. "CDS" and
        "complement(join(490883..490885,1..879))") while qualifiers
        is a list of two string tuples (feature qualifier keys and values).

        Assumes you have already read to the start of the features table.
        """
        ...
    
    def parse_feature(self, feature_key, lines):
        r"""Parse a feature given as a list of strings into a tuple.

        Expects a feature as a list of strings, returns a tuple (key, location,
        qualifiers)

        For example given this GenBank feature::

             CDS             complement(join(490883..490885,1..879))
                             /locus_tag="NEQ001"
                             /note="conserved hypothetical [Methanococcus jannaschii];
                             COG1583:Uncharacterized ACR; IPR001472:Bipartite nuclear
                             localization signal; IPR002743: Protein of unknown
                             function DUF57"
                             /codon_start=1
                             /transl_table=11
                             /product="hypothetical protein"
                             /protein_id="NP_963295.1"
                             /db_xref="GI:41614797"
                             /db_xref="GeneID:2732620"
                             /translation="MRLLLELKALNSIDKKQLSNYLIQGFIYNILKNTEYSWLHNWKK
                             EKYFNFTLIPKKDIIENKRYYLIISSPDKRFIEVLHNKIKDLDIITIGLAQFQLRKTK
                             KFDPKLRFPWVTITPIVLREGKIVILKGDKYYKVFVKRLEELKKYNLIKKKEPILEEP
                             IEISLNQIKDGWKIIDVKDRYYDFRNKSFSAFSNWLRDLKEQSLRKYNNFCGKNFYFE
                             EAIFEGFTFYKTVSIRIRINRGEAVYIGTLWKELNVYRKLDKEEREFYKFLYDCGLGS
                             LNSMGFGFVNTKKNSAR"

        Then should give input key="CDS" and the rest of the data as a list of strings
        lines=["complement(join(490883..490885,1..879))", ..., "LNSMGFGFVNTKKNSAR"]
        where the leading spaces and trailing newlines have been removed.

        Returns tuple containing: (key as string, location string, qualifiers as list)
        as follows for this example:

        key = "CDS", string
        location = "complement(join(490883..490885,1..879))", string
        qualifiers = list of string tuples:

        [('locus_tag', '"NEQ001"'),
         ('note', '"conserved hypothetical [Methanococcus jannaschii];\nCOG1583:..."'),
         ('codon_start', '1'),
         ('transl_table', '11'),
         ('product', '"hypothetical protein"'),
         ('protein_id', '"NP_963295.1"'),
         ('db_xref', '"GI:41614797"'),
         ('db_xref', '"GeneID:2732620"'),
         ('translation', '"MRLLLELKALNSIDKKQLSNYLIQGFIYNILKNTEYSWLHNWKK\nEKYFNFT..."')]

        In the above example, the "note" and "translation" were edited for compactness,
        and they would contain multiple new line characters (displayed above as \n)

        If a qualifier is quoted (in this case, everything except codon_start and
        transl_table) then the quotes are NOT removed.

        Note that no whitespace is removed.
        """
        ...
    
    def parse_footer(self): # -> tuple[list[Unknown], Literal['']]:
        """Return a tuple containing a list of any misc strings, and the sequence."""
        ...
    
    def feed(self, handle, consumer, do_features=...): # -> bool:
        """Feed a set of data into the consumer.

        This method is intended for use with the "old" code in Bio.GenBank

        Arguments:
         - handle - A handle with the information to parse.
         - consumer - The consumer that should be informed of events.
         - do_features - Boolean, should the features be parsed?
           Skipping the features can be much faster.

        Return values:
         - true  - Passed a record
         - false - Did not find a record

        """
        ...
    
    def parse(self, handle, do_features=...): # -> SeqRecord | None:
        """Return a SeqRecord (with SeqFeatures if do_features=True).

        See also the method parse_records() for use on multi-record files.
        """
        ...
    
    def parse_records(self, handle, do_features=...): # -> Generator[SeqRecord, None, None]:
        """Parse records, return a SeqRecord object iterator.

        Each record (from the ID/LOCUS line to the // line) becomes a SeqRecord

        The SeqRecord objects include SeqFeatures if do_features=True

        This method is intended for use in Bio.SeqIO
        """
        ...
    
    def parse_cds_features(self, handle, alphabet=..., tags2id=...):
        """Parse CDS features, return SeqRecord object iterator.

        Each CDS feature becomes a SeqRecord.

        Arguments:
         - alphabet - Obsolete, should be left as None.
         - tags2id  - Tupple of three strings, the feature keys to use
           for the record id, name and description,

        This method is intended for use in Bio.SeqIO

        """
        ...
    


class EmblScanner(InsdcScanner):
    """For extracting chunks of information in EMBL files."""
    RECORD_START = ...
    HEADER_WIDTH = ...
    FEATURE_START_MARKERS = ...
    FEATURE_END_MARKERS = ...
    FEATURE_QUALIFIER_INDENT = ...
    FEATURE_QUALIFIER_SPACER = ...
    SEQUENCE_HEADERS = ...
    EMBL_INDENT = ...
    EMBL_SPACER = ...
    def parse_footer(self): # -> tuple[list[Unknown], str]:
        """Return a tuple containing a list of any misc strings, and the sequence."""
        ...
    


class _ImgtScanner(EmblScanner):
    """For extracting chunks of information in IMGT (EMBL like) files (PRIVATE).

    IMGT files are like EMBL files but in order to allow longer feature types
    the features should be indented by 25 characters not 21 characters. In
    practice the IMGT flat files tend to use either 21 or 25 characters, so we
    must cope with both.

    This is private to encourage use of Bio.SeqIO rather than Bio.GenBank.
    """
    FEATURE_START_MARKERS = ...
    def parse_features(self, skip=...):
        """Return list of tuples for the features (if present).

        Each feature is returned as a tuple (key, location, qualifiers)
        where key and location are strings (e.g. "CDS" and
        "complement(join(490883..490885,1..879))") while qualifiers
        is a list of two string tuples (feature qualifier keys and values).

        Assumes you have already read to the start of the features table.
        """
        ...
    


class GenBankScanner(InsdcScanner):
    """For extracting chunks of information in GenBank files."""
    RECORD_START = ...
    HEADER_WIDTH = ...
    FEATURE_START_MARKERS = ...
    FEATURE_END_MARKERS = ...
    FEATURE_QUALIFIER_INDENT = ...
    FEATURE_QUALIFIER_SPACER = ...
    SEQUENCE_HEADERS = ...
    GENBANK_INDENT = ...
    GENBANK_SPACER = ...
    STRUCTURED_COMMENT_START = ...
    STRUCTURED_COMMENT_END = ...
    STRUCTURED_COMMENT_DELIM = ...
    def parse_footer(self): # -> tuple[list[Unknown], str]:
        """Return a tuple containing a list of any misc strings, and the sequence."""
        ...
    


