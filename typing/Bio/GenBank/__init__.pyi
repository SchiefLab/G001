"""
This type stub file was generated by pyright.
"""

import re
import warnings
from Bio import BiopythonParserWarning, SeqFeature
from Bio.Seq import Seq
from .utils import FeatureValueCleaner
from .Scanner import GenBankScanner
from Bio._utils import run_doctest

"""Code to work with GenBank formatted files.

Rather than using Bio.GenBank, you are now encouraged to use Bio.SeqIO with
the "genbank" or "embl" format names to parse GenBank or EMBL files into
SeqRecord and SeqFeature objects (see the Biopython tutorial for details).

Using Bio.GenBank directly to parse GenBank files is only useful if you want
to obtain GenBank-specific Record objects, which is a much closer
representation to the raw file contents than the SeqRecord alternative from
the FeatureParser (used in Bio.SeqIO).

To use the Bio.GenBank parser, there are two helper functions:

    - read                  Parse a handle containing a single GenBank record
      as Bio.GenBank specific Record objects.
    - parse                 Iterate over a handle containing multiple GenBank
      records as Bio.GenBank specific Record objects.

The following internal classes are not intended for direct use and may
be deprecated in a future release.

Classes:
 - Iterator              Iterate through a file of GenBank entries
 - ErrorFeatureParser    Catch errors caused during parsing.
 - FeatureParser         Parse GenBank data in SeqRecord and SeqFeature objects.
 - RecordParser          Parse GenBank data into a Record object.

Exceptions:
 - ParserFailureError    Exception indicating a failure in the parser (ie.
   scanner or consumer)
 - LocationParserError   Exception indicating a problem with the spark based
   location parser.

"""
GENBANK_INDENT = ...
GENBANK_SPACER = ...
FEATURE_KEY_INDENT = ...
FEATURE_QUALIFIER_INDENT = ...
FEATURE_KEY_SPACER = ...
FEATURE_QUALIFIER_SPACER = ...
_solo_location = ...
_pair_location = ...
_between_location = ...
_within_position = ...
_re_within_position = ...
_within_location = ...
_oneof_position = ...
_re_oneof_position = ...
_oneof_location = ...
_simple_location = ...
_re_simple_location = ...
_re_simple_compound = ...
_complex_location = ...
_re_complex_location = ...
_possibly_complemented_complex_location = ...
_re_complex_compound = ...
_solo_bond = ...
class Iterator:
    """Iterator interface to move over a file of GenBank entries one at a time (OBSOLETE).

    This class is likely to be deprecated in a future release of Biopython.
    Please use Bio.SeqIO.parse(..., format="gb") or Bio.GenBank.parse(...)
    for SeqRecord and GenBank specific Record objects respectively instead.
    """
    def __init__(self, handle, parser=...) -> None:
        """Initialize the iterator.

        Arguments:
         - handle - A handle with GenBank entries to iterate through.
         - parser - An optional parser to pass the entries through before
           returning them. If None, then the raw entry will be returned.

        """
        ...
    
    def __next__(self): # -> str | None:
        """Return the next GenBank record from the handle.

        Will return None if we ran out of records.
        """
        ...
    
    def __iter__(self): # -> Iterator[str | Unknown]:
        """Iterate over the records."""
        ...
    


class ParserFailureError(Exception):
    """Failure caused by some kind of problem in the parser."""
    ...


class LocationParserError(Exception):
    """Could not Properly parse out a location from a GenBank file."""
    ...


_cleaner = ...
class FeatureParser:
    """Parse GenBank files into Seq + Feature objects (OBSOLETE).

    Direct use of this class is discouraged, and may be deprecated in
    a future release of Biopython.

    Please use Bio.SeqIO.parse(...) or Bio.SeqIO.read(...) instead.
    """
    def __init__(self, debug_level=..., use_fuzziness=..., feature_cleaner=...) -> None:
        """Initialize a GenBank parser and Feature consumer.

        Arguments:
         - debug_level - An optional argument that species the amount of
           debugging information the parser should spit out. By default we have
           no debugging info (the fastest way to do things), but if you want
           you can set this as high as two and see exactly where a parse fails.
         - use_fuzziness - Specify whether or not to use fuzzy representations.
           The default is 1 (use fuzziness).
         - feature_cleaner - A class which will be used to clean out the
           values of features. This class must implement the function
           clean_value. GenBank.utils has a "standard" cleaner class, which
           is used by default.

        """
        ...
    
    def parse(self, handle): # -> SeqRecord:
        """Parse the specified handle."""
        ...
    


class RecordParser:
    """Parse GenBank files into Record objects (OBSOLETE).

    Direct use of this class is discouraged, and may be deprecated in
    a future release of Biopython.

    Please use the Bio.GenBank.parse(...) or Bio.GenBank.read(...) functions
    instead.
    """
    def __init__(self, debug_level=...) -> None:
        """Initialize the parser.

        Arguments:
         - debug_level - An optional argument that species the amount of
           debugging information the parser should spit out. By default we have
           no debugging info (the fastest way to do things), but if you want
           you can set this as high as two and see exactly where a parse fails.

        """
        ...
    
    def parse(self, handle): # -> Record:
        """Parse the specified handle into a GenBank record."""
        ...
    


class _BaseGenBankConsumer:
    """Abstract GenBank consumer providing useful general functions (PRIVATE).

    This just helps to eliminate some duplication in things that most
    GenBank consumers want to do.
    """
    remove_space_keys = ...
    def __init__(self) -> None:
        ...
    


class _FeatureConsumer(_BaseGenBankConsumer):
    """Create a SeqRecord object with Features to return (PRIVATE).

    Attributes:
     - use_fuzziness - specify whether or not to parse with fuzziness in
       feature locations.
     - feature_cleaner - a class that will be used to provide specialized
       cleaning-up of feature values.

    """
    def __init__(self, use_fuzziness, feature_cleaner=...) -> None:
        ...
    
    def locus(self, locus_name): # -> None:
        """Set the locus name is set as the name of the Sequence."""
        ...
    
    def size(self, content): # -> None:
        """Record the sequence length."""
        ...
    
    def residue_type(self, type): # -> None:
        """Record the sequence type (SEMI-OBSOLETE).

        This reflects the fact that the topology (linear/circular) and
        molecule type (e.g. DNA vs RNA) were a single field in early
        files. Current GenBank/EMBL files have two fields.
        """
        ...
    
    def topology(self, topology): # -> None:
        """Validate and record sequence topology.

        The topology argument should be "linear" or "circular" (string).
        """
        ...
    
    def molecule_type(self, mol_type): # -> None:
        """Validate and record the molecule type (for round-trip etc)."""
        ...
    
    def data_file_division(self, division): # -> None:
        ...
    
    def date(self, submit_date): # -> None:
        ...
    
    def definition(self, definition): # -> None:
        """Set the definition as the description of the sequence."""
        ...
    
    def accession(self, acc_num):
        """Set the accession number as the id of the sequence.

        If we have multiple accession numbers, the first one passed is
        used.
        """
        ...
    
    def tls(self, content): # -> None:
        ...
    
    def tsa(self, content): # -> None:
        ...
    
    def wgs(self, content): # -> None:
        ...
    
    def add_wgs_scafld(self, content): # -> None:
        ...
    
    def nid(self, content): # -> None:
        ...
    
    def pid(self, content): # -> None:
        ...
    
    def version(self, version_id): # -> None:
        ...
    
    def project(self, content): # -> None:
        """Handle the information from the PROJECT line as a list of projects.

        e.g.::

            PROJECT     GenomeProject:28471

        or::

            PROJECT     GenomeProject:13543  GenomeProject:99999

        This is stored as dbxrefs in the SeqRecord to be consistent with the
        projected switch of this line to DBLINK in future GenBank versions.
        Note the NCBI plan to replace "GenomeProject:28471" with the shorter
        "Project:28471" as part of this transition.
        """
        ...
    
    def dblink(self, content): # -> None:
        """Store DBLINK cross references as dbxrefs in our record object.

        This line type is expected to replace the PROJECT line in 2009. e.g.

        During transition::

            PROJECT     GenomeProject:28471
            DBLINK      Project:28471
                        Trace Assembly Archive:123456

        Once the project line is dropped::

            DBLINK      Project:28471
                        Trace Assembly Archive:123456

        Note GenomeProject -> Project.

        We'll have to see some real examples to be sure, but based on the
        above example we can expect one reference per line.

        Note that at some point the NCBI have included an extra space, e.g.::

            DBLINK      Project: 28471

        """
        ...
    
    def version_suffix(self, version): # -> None:
        """Set the version to overwrite the id.

        Since the version provides the same information as the accession
        number, plus some extra info, we set this as the id if we have
        a version.
        """
        ...
    
    def db_source(self, content): # -> None:
        ...
    
    def gi(self, content): # -> None:
        ...
    
    def keywords(self, content): # -> None:
        ...
    
    def segment(self, content): # -> None:
        ...
    
    def source(self, content): # -> None:
        ...
    
    def organism(self, content): # -> None:
        ...
    
    def taxonomy(self, content): # -> None:
        """Record (another line of) the taxonomy lineage."""
        ...
    
    def reference_num(self, content): # -> None:
        """Signal the beginning of a new reference object."""
        ...
    
    def reference_bases(self, content): # -> None:
        """Attempt to determine the sequence region the reference entails.

        Possible types of information we may have to deal with:

        (bases 1 to 86436)
        (sites)
        (bases 1 to 105654; 110423 to 111122)
        1  (residues 1 to 182)
        """
        ...
    
    def authors(self, content): # -> None:
        ...
    
    def consrtm(self, content): # -> None:
        ...
    
    def title(self, content): # -> None:
        ...
    
    def journal(self, content): # -> None:
        ...
    
    def medline_id(self, content): # -> None:
        ...
    
    def pubmed_id(self, content): # -> None:
        ...
    
    def remark(self, content): # -> None:
        """Deal with a reference comment."""
        ...
    
    def comment(self, content): # -> None:
        ...
    
    def structured_comment(self, content): # -> None:
        ...
    
    def features_line(self, content): # -> None:
        """Get ready for the feature table when we reach the FEATURE line."""
        ...
    
    def start_feature_table(self): # -> None:
        """Indicate we've got to the start of the feature table."""
        ...
    
    def feature_key(self, content): # -> None:
        ...
    
    def location(self, content):
        """Parse out location information from the location string.

        This uses simple Python code with some regular expressions to do the
        parsing, and then translates the results into appropriate objects.
        """
        ...
    
    def feature_qualifier(self, key, value): # -> None:
        """When we get a qualifier key and its value.

        Can receive None, since you can have valueless keys such as /pseudo
        """
        ...
    
    def feature_qualifier_name(self, content_list):
        """Use feature_qualifier instead (OBSOLETE)."""
        ...
    
    def feature_qualifier_description(self, content):
        """Use feature_qualifier instead (OBSOLETE)."""
        ...
    
    def contig_location(self, content): # -> None:
        """Deal with CONTIG information."""
        ...
    
    def origin_name(self, content): # -> None:
        ...
    
    def base_count(self, content): # -> None:
        ...
    
    def base_number(self, content): # -> None:
        ...
    
    def sequence(self, content): # -> None:
        """Add up sequence information as we get it.

        To try and make things speedier, this puts all of the strings
        into a list of strings, and then uses string.join later to put
        them together. Supposedly, this is a big time savings
        """
        ...
    
    def record_end(self, content):
        """Clean up when we've finished the record."""
        ...
    


class _RecordConsumer(_BaseGenBankConsumer):
    """Create a GenBank Record object from scanner generated information (PRIVATE)."""
    def __init__(self) -> None:
        ...
    
    def tls(self, content): # -> None:
        ...
    
    def tsa(self, content): # -> None:
        ...
    
    def wgs(self, content): # -> None:
        ...
    
    def add_wgs_scafld(self, content): # -> None:
        ...
    
    def locus(self, content): # -> None:
        ...
    
    def size(self, content): # -> None:
        ...
    
    def residue_type(self, content): # -> None:
        ...
    
    def data_file_division(self, content): # -> None:
        ...
    
    def date(self, content): # -> None:
        ...
    
    def definition(self, content): # -> None:
        ...
    
    def accession(self, content): # -> None:
        ...
    
    def molecule_type(self, mol_type): # -> None:
        """Validate and record the molecule type (for round-trip etc)."""
        ...
    
    def topology(self, topology): # -> None:
        """Validate and record sequence topology.

        The topology argument should be "linear" or "circular" (string).
        """
        ...
    
    def nid(self, content): # -> None:
        ...
    
    def pid(self, content): # -> None:
        ...
    
    def version(self, content): # -> None:
        ...
    
    def db_source(self, content): # -> None:
        ...
    
    def gi(self, content): # -> None:
        ...
    
    def keywords(self, content): # -> None:
        ...
    
    def project(self, content): # -> None:
        ...
    
    def dblink(self, content): # -> None:
        ...
    
    def segment(self, content): # -> None:
        ...
    
    def source(self, content): # -> None:
        ...
    
    def organism(self, content): # -> None:
        ...
    
    def taxonomy(self, content): # -> None:
        ...
    
    def reference_num(self, content): # -> None:
        """Grab the reference number and signal the start of a new reference."""
        ...
    
    def reference_bases(self, content): # -> None:
        ...
    
    def authors(self, content): # -> None:
        ...
    
    def consrtm(self, content): # -> None:
        ...
    
    def title(self, content): # -> None:
        ...
    
    def journal(self, content): # -> None:
        ...
    
    def medline_id(self, content): # -> None:
        ...
    
    def pubmed_id(self, content): # -> None:
        ...
    
    def remark(self, content): # -> None:
        ...
    
    def comment(self, content): # -> None:
        ...
    
    def structured_comment(self, content): # -> None:
        ...
    
    def primary_ref_line(self, content): # -> None:
        """Save reference data for the PRIMARY line."""
        ...
    
    def primary(self, content): # -> None:
        ...
    
    def features_line(self, content): # -> None:
        """Get ready for the feature table when we reach the FEATURE line."""
        ...
    
    def start_feature_table(self): # -> None:
        """Signal the start of the feature table."""
        ...
    
    def feature_key(self, content): # -> None:
        """Grab the key of the feature and signal the start of a new feature."""
        ...
    
    def location(self, content): # -> None:
        ...
    
    def feature_qualifier(self, key, value): # -> None:
        ...
    
    def feature_qualifier_name(self, content_list): # -> None:
        """Deal with qualifier names.

        We receive a list of keys, since you can have valueless keys such as
        /pseudo which would be passed in with the next key (since no other
        tags separate them in the file)
        """
        ...
    
    def feature_qualifier_description(self, content): # -> None:
        ...
    
    def base_count(self, content): # -> None:
        ...
    
    def origin_name(self, content): # -> None:
        ...
    
    def contig_location(self, content): # -> None:
        """Signal that we have contig information to add to the record."""
        ...
    
    def sequence(self, content): # -> None:
        """Add sequence information to a list of sequence strings.

        This removes spaces in the data and uppercases the sequence, and
        then adds it to a list of sequences. Later on we'll join this
        list together to make the final sequence. This is faster than
        adding on the new string every time.
        """
        ...
    
    def record_end(self, content): # -> None:
        """Signal the end of the record and do any necessary clean-up."""
        ...
    


def parse(handle): # -> Iterator[str | Unknown]:
    """Iterate over GenBank formatted entries as Record objects.

    >>> from Bio import GenBank
    >>> with open("GenBank/NC_000932.gb") as handle:
    ...     for record in GenBank.parse(handle):
    ...         print(record.accession)
    ['NC_000932']

    To get SeqRecord objects use Bio.SeqIO.parse(..., format="gb")
    instead.
    """
    ...

def read(handle): # -> str:
    """Read a handle containing a single GenBank entry as a Record object.

    >>> from Bio import GenBank
    >>> with open("GenBank/NC_000932.gb") as handle:
    ...     record = GenBank.read(handle)
    ...     print(record.accession)
    ['NC_000932']

    To get a SeqRecord object use Bio.SeqIO.read(..., format="gb")
    instead.
    """
    ...

if __name__ == "__main__":
    ...
