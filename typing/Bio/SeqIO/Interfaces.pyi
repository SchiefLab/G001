"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod

"""Bio.SeqIO support module (not for general use).

Unless you are writing a new parser or writer for Bio.SeqIO, you should not
use this module.  It provides base classes to try and simplify things.
"""
class SequenceIterator(ABC):
    """Base class for building SeqRecord iterators.

    You should write a parse method that returns a SeqRecord generator.  You
    may wish to redefine the __init__ method as well.
    """
    def __init__(self, source, alphabet=..., mode=..., fmt=...) -> None:
        """Create a SequenceIterator object.

        Arguments:
        - source - input file stream, or path to input file
        - alphabet - no longer used, should be None

        This method MAY be overridden by any subclass.

        Note when subclassing:
        - there should be a single non-optional argument, the source.
        - you do not have to require an alphabet.
        - you can add additional optional arguments.
        """
        ...
    
    def __next__(self):
        ...
    
    def __iter__(self): # -> Self@SequenceIterator:
        """Iterate over the entries as a SeqRecord objects.

        Example usage for Fasta files::

            with open("example.fasta","r") as myFile:
                myFastaReader = FastaIterator(myFile)
                for record in myFastaReader:
                    print(record.id)
                    print(record.seq)

        This method SHOULD NOT be overridden by any subclass. It should be
        left as is, which will call the subclass implementation of __next__
        to actually parse the file.
        """
        ...
    
    @abstractmethod
    def parse(self, handle): # -> None:
        """Start parsing the file, and return a SeqRecord iterator."""
        ...
    


class SequenceWriter:
    """Base class for sequence writers. This class should be subclassed.

    It is intended for sequential file formats with an (optional)
    header, repeated records, and an (optional) footer, as well
    as for interlaced file formats such as Clustal.

    The user may call the write_file() method to write a complete
    file containing the sequences.

    Alternatively, users may call the write_header(), followed
    by multiple calls to write_record() and/or write_records(),
    followed finally by write_footer().

    Note that write_header() cannot require any assumptions about
    the number of records.
    """
    def __init__(self, target, mode=...) -> None:
        """Create the writer object."""
        ...
    
    def clean(self, text):
        """Use this to avoid getting newlines in the output."""
        ...
    
    def write_header(self): # -> None:
        """Write the file header to the output file."""
        ...
    
    def write_footer(self): # -> None:
        """Write the file footer to the output file."""
        ...
    
    def write_record(self, record):
        """Write a single record to the output file.

        record - a SeqRecord object
        """
        ...
    
    def write_records(self, records, maxcount=...): # -> int:
        """Write records to the output file, and return the number of records.

        records - A list or iterator returning SeqRecord objects
        maxcount - The maximum number of records allowed by the
        file format, or None if there is no maximum.
        """
        ...
    
    def write_file(self, records, mincount=..., maxcount=...): # -> int:
        """Write a complete file with the records, and return the number of records.

        records - A list or iterator returning SeqRecord objects
        """
        ...
    


class SequentialSequenceWriter(SequenceWriter):
    """Base class for sequential sequence writers (DEPRECATED).

    This class should be subclassed. It is no longer used.
    It was intended for sequential file formats with an (optional)
    header, repeated records, and an (optional) footer. It would
    enforce callign the methods in appropriate order. To update
    code using ``SequentialSequenceWriter``, just subclass
    ``SequenceWriter`` and drop the ``._header_written`` etc
    checks (or reimplement them).

    In this case (as with interlaced file formats), the user may
    simply call the write_file() method and be done.

    However, they may also call the write_header(), followed
    by multiple calls to write_record() and/or write_records()
    followed finally by write_footer().

    Users must call write_header() and write_footer() even when
    the file format concerned doesn't have a header or footer.
    This is to try and make life as easy as possible when
    switching the output format.

    Note that write_header() cannot require any assumptions about
    the number of records.
    """
    def __init__(self, target, mode=...) -> None:
        """Initialize the class."""
        ...
    
    def write_header(self): # -> None:
        """Write the file header.

        If your file format defines a header, you should implement this method
        in order to write the header before any of the records.

        The default implementation checks the private attribute ._header_written
        to ensure the header is only written once.
        """
        ...
    
    def write_footer(self): # -> None:
        """Write the file footer.

        If your file format defines a footer, you should implement this method
        in order to write the footer after all the records.

        The default implementation checks the private attribute ._footer_written
        to ensure the footer is only written once.
        """
        ...
    
    def write_record(self, record):
        """Write a single record to the output file.

        record - a SeqRecord object

        Once you have called write_header() you can call write_record()
        and/or write_records() as many times as needed.  Then call
        write_footer() and close().
        """
        ...
    
    def write_records(self, records): # -> int:
        """Write multiple record to the output file.

        records - A list or iterator returning SeqRecord objects

        Once you have called write_header() you can call write_record()
        and/or write_records() as many times as needed.  Then call
        write_footer() and close().

        Returns the number of records written.
        """
        ...
    
    def write_file(self, records): # -> int:
        """Use this to write an entire file containing the given records.

        records - A list or iterator returning SeqRecord objects

        This method can only be called once.  Returns the number of records
        written.
        """
        ...
    


