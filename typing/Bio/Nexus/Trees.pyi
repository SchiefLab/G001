"""
This type stub file was generated by pyright.
"""

from . import Nodes

"""Tree class to handle phylogenetic trees.

Provides a set of methods to read and write newick-format tree descriptions,
get information about trees (monphyly of taxon sets, congruence between trees,
common ancestors,...) and to manipulate trees (re-root trees, split terminal
nodes).
"""
PRECISION_BRANCHLENGTH = ...
PRECISION_SUPPORT = ...
NODECOMMENT_START = ...
NODECOMMENT_END = ...
class TreeError(Exception):
    """Provision for the management of Tree exceptions."""
    ...


class NodeData:
    """Store tree-relevant data associated with nodes (e.g. branches or otus)."""
    def __init__(self, taxon=..., branchlength=..., support=..., comment=...) -> None:
        """Initialize the class."""
        ...
    


class Tree(Nodes.Chain):
    """Represent a tree using a chain of nodes with on predecessor (=ancestor) and multiple successors (=subclades)."""
    def __init__(self, tree=..., weight=..., rooted=..., name=..., data=..., values_are_support=..., max_support=...) -> None:
        """Ntree(self,tree)."""
        ...
    
    def node(self, node_id):
        """Return the instance of node_id.

        node = node(self,node_id)
        """
        ...
    
    def split(self, parent_id=..., n=..., branchlength=...): # -> list[Unknown]:
        """Speciation: generates n (default two) descendants of a node.

        [new ids] = split(self,parent_id=None,n=2,branchlength=1.0):
        """
        ...
    
    def search_taxon(self, taxon): # -> None:
        """Return the first matching taxon in self.data.taxon. Not restricted to terminal nodes.

        node_id = search_taxon(self,taxon)

        """
        ...
    
    def prune(self, taxon):
        """Prune a terminal taxon from the tree.

        id_of_previous_node = prune(self,taxon)
        If taxon is from a bifurcation, the connectiong node will be collapsed
        and its branchlength added to remaining terminal node. This might be no
        longer a meaningful value'
        """
        ...
    
    def get_taxa(self, node_id=...): # -> list[Unknown] | None:
        """Return a list of all otus downwards from a node.

        nodes = get_taxa(self,node_id=None)
        """
        ...
    
    def get_terminals(self): # -> list[Unknown]:
        """Return a list of all terminal nodes."""
        ...
    
    def is_terminal(self, node):
        """Return True if node is a terminal node."""
        ...
    
    def is_internal(self, node): # -> bool:
        """Return True if node is an internal node."""
        ...
    
    def is_preterminal(self, node): # -> bool:
        """Return True if all successors of a node are terminal ones."""
        ...
    
    def count_terminals(self, node=...): # -> int:
        """Count the number of terminal nodes that are attached to a node."""
        ...
    
    def collapse_genera(self, space_equals_underscore=...): # -> None:
        """Collapse all subtrees which belong to the same genus.

        (i.e share the same first word in their taxon name.)
        """
        ...
    
    def sum_branchlength(self, root=..., node=...): # -> float:
        """Add up the branchlengths from root (default self.root) to node.

        sum = sum_branchlength(self,root=None,node=None)
        """
        ...
    
    def set_subtree(self, node): # -> frozenset[Unknown]:
        """Return subtree as a set of nested sets.

        sets = set_subtree(self,node)
        """
        ...
    
    def is_identical(self, tree2):
        """Compare tree and tree2 for identity.

        result = is_identical(self,tree2)
        """
        ...
    
    def is_compatible(self, tree2, threshold, strict=...):
        """Compare branches with support>threshold for compatibility.

        result = is_compatible(self,tree2,threshold)
        """
        ...
    
    def common_ancestor(self, node1, node2):
        """Return the common ancestor that connects two nodes.

        node_id = common_ancestor(self,node1,node2)
        """
        ...
    
    def distance(self, node1, node2): # -> float:
        """Add and return the sum of the branchlengths between two nodes.

        dist = distance(self,node1,node2)
        """
        ...
    
    def is_monophyletic(self, taxon_list): # -> int:
        """Return node_id of common ancestor if taxon_list is monophyletic, -1 otherwise.

        result = is_monophyletic(self,taxon_list)
        """
        ...
    
    def is_bifurcating(self, node=...):
        """Return True if tree downstream of node is strictly bifurcating."""
        ...
    
    def branchlength2support(self): # -> None:
        """Move values stored in data.branchlength to data.support, and set branchlength to 0.0.

        This is necessary when support has been stored as branchlength (e.g. paup), and has thus
        been read in as branchlength.
        """
        ...
    
    def convert_absolute_support(self, nrep): # -> None:
        """Convert absolute support (clade-count) to rel. frequencies.

        Some software (e.g. PHYLIP consense) just calculate how often clades appear, instead of
        calculating relative frequencies.
        """
        ...
    
    def has_support(self, node=...): # -> bool:
        """Return True if any of the nodes has data.support != None."""
        ...
    
    def randomize(self, ntax=..., taxon_list=..., branchlength=..., branchlength_sd=..., bifurcate=...):
        """Generate a random tree with ntax taxa and/or taxa from taxlabels.

        new_tree = randomize(self,ntax=None,taxon_list=None,branchlength=1.0,branchlength_sd=None,bifurcate=True)
        Trees are bifurcating by default. (Polytomies not yet supported).
        """
        ...
    
    def display(self): # -> None:
        """Quick and dirty lists of all nodes."""
        ...
    
    def to_string(self, support_as_branchlengths=..., branchlengths_only=..., plain=..., plain_newick=..., ladderize=..., ignore_comments=...):
        """Return a paup compatible tree line."""
        ...
    
    def __str__(self) -> str:
        """Short version of to_string(), gives plain tree."""
        ...
    
    def unroot(self): # -> None:
        """Define a unrooted Tree structure, using data of a rooted Tree."""
        ...
    
    def root_with_outgroup(self, outgroup=...):
        """Define a tree's root with a reference group outgroup."""
        ...
    
    def merge_with_support(self, bstrees=..., constree=..., threshold=..., outgroup=...):
        """Merge clade support (from consensus or list of bootstrap-trees) with phylogeny.

        tree=merge_bootstrap(phylo,bs_tree=<list_of_trees>)
        or
        tree=merge_bootstrap(phylo,consree=consensus_tree with clade support)
        """
        ...
    


def consensus(trees, threshold=..., outgroup=...):
    """Compute a majority rule consensus tree of all clades with relative frequency>=threshold from a list of trees."""
    ...

