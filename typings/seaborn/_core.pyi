"""
This type stub file was generated by pyright.
"""

from ._decorators import share_init_params_with_map

class SemanticMapping:
    """Base class for mapping data values to plot attributes."""
    map_type = ...
    levels = ...
    lookup_table = ...
    def __init__(self, plotter) -> None:
        ...
    
    def map(cls, plotter, *args, **kwargs):
        ...
    
    def __call__(self, key, *args, **kwargs): # -> list[Unknown]:
        """Get the attribute(s) values for the data key."""
        ...
    


@share_init_params_with_map
class HueMapping(SemanticMapping):
    """Mapping that sets artist colors according to data values."""
    palette = ...
    norm = ...
    cmap = ...
    def __init__(self, plotter, palette=..., order=..., norm=...) -> None:
        """Map the levels of the `hue` variable to distinct colors.

        Parameters
        ----------
        # TODO add generic parameters

        """
        ...
    
    def infer_map_type(self, palette, norm, input_format, var_type): # -> Literal['categorical', 'numeric']:
        """Determine how to implement the mapping."""
        ...
    
    def categorical_mapping(self, data, palette, order): # -> tuple[list[Any], dict[Unknown, Unknown]]:
        """Determine colors when the hue mapping is categorical."""
        ...
    
    def numeric_mapping(self, data, palette, norm): # -> tuple[list[Unknown] | list[Any], dict[Unknown, Unknown] | dict[Any, Any], Unknown | Normalize, ListedColormap | Colormap | _ColorPalette | list[tuple[float, float, float]] | list[str] | LinearSegmentedColormap]:
        """Determine colors when the hue variable is quantitative."""
        ...
    


@share_init_params_with_map
class SizeMapping(SemanticMapping):
    """Mapping that sets artist sizes according to data values."""
    norm = ...
    def __init__(self, plotter, sizes=..., order=..., norm=...) -> None:
        """Map the levels of the `size` variable to distinct values.

        Parameters
        ----------
        # TODO add generic parameters

        """
        ...
    
    def infer_map_type(self, norm, sizes, var_type): # -> Literal['numeric', 'categorical']:
        ...
    
    def categorical_mapping(self, data, sizes, order): # -> tuple[list[Any], dict[Unknown, Unknown] | dict[Any, Any]]:
        ...
    
    def numeric_mapping(self, data, sizes, norm): # -> tuple[list[Any], dict[Unknown, Unknown] | Unknown | dict[Any, Any], Normalize, tuple[Unknown, Unknown] | tuple[Unknown, ...] | Unknown]:
        ...
    


@share_init_params_with_map
class StyleMapping(SemanticMapping):
    """Mapping that sets artist style according to data values."""
    map_type = ...
    def __init__(self, plotter, markers=..., dashes=..., order=...) -> None:
        """Map the levels of the `style` variable to distinct values.

        Parameters
        ----------
        # TODO add generic parameters

        """
        ...
    


class VectorPlotter:
    """Base class for objects underlying *plot functions."""
    _semantic_mappings = ...
    semantics = ...
    wide_structure = ...
    flat_structure = ...
    _default_size_range = ...
    def __init__(self, data=..., variables=...) -> None:
        ...
    
    @classmethod
    def get_semantics(cls, kwargs, semantics=...): # -> dict[Unknown, Unknown]:
        """Subset a dictionary` arguments with known semantic variables."""
        ...
    
    @property
    def has_xy_data(self): # -> bool:
        """Return True at least one of x or y is defined."""
        ...
    
    @property
    def var_levels(self): # -> dict[Unknown, Unknown]:
        """Property interface to ordered list of variables levels.

        Each time it's accessed, it updates the var_levels dictionary with the
        list of levels in the current semantic mappers. But it also allows the
        dictionary to persist, so it can be used to set levels by a key. This is
        used to track the list of col/row levels using an attached FacetGrid
        object, but it's kind of messy and ideally fixed by improving the
        faceting logic so it interfaces better with the modern approach to
        tracking plot variables.

        """
        ...
    
    def assign_variables(self, data=..., variables=...): # -> Self@VectorPlotter:
        """Define plot variables, optionally using lookup from `data`."""
        ...
    
    def iter_data(self, grouping_vars=..., reverse=..., from_comp_data=...): # -> Generator[tuple[dict[Any, Any], Unknown] | tuple[dict[Unknown, Unknown], DataFrame], None, None]:
        """Generator for getting subsets of data defined by semantic variables.

        Also injects "col" and "row" into grouping semantics.

        Parameters
        ----------
        grouping_vars : string or list of strings
            Semantic variables that define the subsets of data.
        reverse : bool, optional
            If True, reverse the order of iteration.
        from_comp_data : bool, optional
            If True, use self.comp_data rather than self.plot_data

        Yields
        ------
        sub_vars : dict
            Keys are semantic names, values are the level of that semantic.
        sub_data : :class:`pandas.DataFrame`
            Subset of ``plot_data`` for this combination of semantic values.

        """
        ...
    
    @property
    def comp_data(self): # -> DataFrame:
        """Dataframe with numeric x and y, after unit conversion and log scaling."""
        ...
    


def variable_type(vector, boolean_type=...): # -> str:
    """
    Determine whether a vector contains numeric, categorical, or datetime data.

    This function differs from the pandas typing API in two ways:

    - Python sequences or object-typed PyData objects are considered numeric if
      all of their entries are numeric.
    - String or mixed-type data are considered categorical even if not
      explicitly represented as a :class:`pandas.api.types.CategoricalDtype`.

    Parameters
    ----------
    vector : :func:`pandas.Series`, :func:`numpy.ndarray`, or Python sequence
        Input data to test.
    boolean_type : 'numeric' or 'categorical'
        Type to use for vectors containing only 0s and 1s (and NAs).

    Returns
    -------
    var_type : 'numeric', 'categorical', or 'datetime'
        Name identifying the type of data in the vector.
    """
    ...

def infer_orient(x=..., y=..., orient=..., require_numeric=...): # -> Literal['v', 'h']:
    """Determine how the plot should be oriented based on the data.

    For historical reasons, the convention is to call a plot "horizontally"
    or "vertically" oriented based on the axis representing its dependent
    variable. Practically, this is used when determining the axis for
    numerical aggregation.

    Parameters
    ----------
    x, y : Vector data or None
        Positional data vectors for the plot.
    orient : string or None
        Specified orientation, which must start with "v" or "h" if not None.
    require_numeric : bool
        If set, raise when the implied dependent variable is not numeric.

    Returns
    -------
    orient : "v" or "h"

    Raises
    ------
    ValueError: When `orient` is not None and does not start with "h" or "v"
    TypeError: When dependant variable is not numeric, with `require_numeric`

    """
    ...

def unique_dashes(n): # -> list[str | tuple[Literal[4], float] | tuple[Literal[1], Literal[1]] | tuple[Literal[3], float, float, float] | tuple[Literal[5], Literal[1], Literal[1], Literal[1]]]:
    """Build an arbitrarily long list of unique dash styles for lines.

    Parameters
    ----------
    n : int
        Number of unique dash specs to generate.

    Returns
    -------
    dashes : list of strings or tuples
        Valid arguments for the ``dashes`` parameter on
        :class:`matplotlib.lines.Line2D`. The first spec is a solid
        line (``""``), the remainder are sequences of long and short
        dashes.

    """
    ...

def unique_markers(n): # -> list[str | tuple[Literal[4], Literal[0], Literal[45]] | tuple[Literal[4], Literal[0], Literal[0]] | tuple[Literal[4], Literal[1], Literal[0]] | tuple[Literal[4], Literal[1], Literal[45]]]:
    """Build an arbitrarily long list of unique marker styles for points.

    Parameters
    ----------
    n : int
        Number of unique marker specs to generate.

    Returns
    -------
    markers : list of string or tuples
        Values for defining :class:`matplotlib.markers.MarkerStyle` objects.
        All markers will be filled.

    """
    ...

def categorical_order(vector, order=...): # -> list[Any]:
    """Return a list of unique data values.

    Determine an ordered list of levels in ``values``.

    Parameters
    ----------
    vector : list, array, Categorical, or Series
        Vector of "categorical" values
    order : list-like, optional
        Desired order of category levels to override the order determined
        from the ``values`` object.

    Returns
    -------
    order : list
        Ordered list of category levels not including null values.

    """
    ...

